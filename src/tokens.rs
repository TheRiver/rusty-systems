//! Tools for handling the tokens that make up strings in the L-system ([`crate::strings::ProductionString`]).
//!
//! Tokens can be of various kinds:
//!
//! * [`TokenKind::Terminal`] are the strict endpoints of the L-System. No production rule can target them.
//! * [`TokenKind::Production`] are those that can be handled by a production rule.
//!
//! Production rules ([`crate::productions::Production`]) will enforce that the target of a
//! production is a token of kind [`TokenKind::Production`].

use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::hash::{Hash, Hasher};
use std::sync::{Arc, Weak};

/// The various kinds of tokens that can make up a [`crate::strings::ProductionString`].
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, PartialOrd)]
pub enum TokenKind {
    /// Terminals are never transformed by production rules. 
    Terminal,
    /// Production tokens may be targets for [`crate::productions::Production`] rules.
    Production
}

impl TokenKind {
    pub fn is_terminal(&self) -> bool {
        matches!(self, TokenKind::Terminal)
    }
    pub fn is_production(&self) -> bool {
        matches!(self, TokenKind::Production)
    }
}

impl Display for TokenKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            TokenKind::Terminal => f.write_str("Terminal"),
            TokenKind::Production => f.write_str("Production")
        }
    }
}

#[derive(Debug, Clone)]
pub struct Token {
    kind: TokenKind,
    code: u32,
    image: Weak<String>
}

impl PartialEq for Token {
    fn eq(&self, other: &Self) -> bool {
        self.kind == other.kind && self.code == other.code
    }
}

impl Eq for Token {}

impl Hash for Token {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.kind.hash(state);
        self.code.hash(state);
    }
}

impl Token {
    pub fn new(kind: TokenKind, code: u32, name: Weak<String>) -> Self {
        Token {
            kind, code, image: name
        }
    }

    pub fn kind(&self) -> TokenKind {
        self.kind
    }

    /// A unique identifier for the token.
    ///
    /// This identifier is set when the token is created (see [`Token::new`]).
    /// The value may not be the same when generated by different instances of [`crate::prelude::System`],
    /// and the value here should not be relied on.
    pub fn code(&self) -> u32 {
        self.code
    }

    /// The name of the string, if it has been stored.
    ///
    /// To access it, do this:
    ///
    /// ```
    /// use std::sync::Weak;
    /// use rusty_systems::tokens::{Token, TokenKind};
    /// let token = Token::new(TokenKind::Terminal, 100, Weak::default());
    ///
    /// if let Some(name) = token.name().upgrade() {
    ///     println!("The name is {name}");
    /// }
    /// ```
    pub fn name(&self) -> &Weak<String> {
        &self.image
    }

    #[inline]
    pub fn is_terminal(&self) -> bool {
        self.kind.is_terminal()
    }

    #[inline]
    pub fn is_production(&self) -> bool {
        self.kind.is_production()
    }
}

impl Display for Token {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if let Some(name) = self.name().upgrade() {
            return f.write_str(name.as_str());
        }

        write!(f, "{}[{}]", self.kind, self.code)
    }
}

pub trait TokenStore {
    fn add_token(&self, name: &str, kind: TokenKind) -> crate::Result<Token>;
    fn get_token(&self, name: &str) -> Option<Token>;
}

impl TokenStore for RefCell<HashMap<Arc<String>, Token>> {
    fn add_token(&self, name: &str, kind: TokenKind) -> crate::Result<Token> {
        let mut map = self.borrow_mut();

        let name = name.to_string();

        // If it already exists, return it.
        if let Some(value) = map.get(&name) {
            return Ok(value.clone());
        }

        let name = Arc::new(name);
        let max = map.values().map(|t| t.code).max().unwrap_or(0);
        let token = Token::new(kind, max + 1, Arc::downgrade(&name));

        map.insert(name, token.clone());
        Ok(token)
    }

    fn get_token(&self, name: &str) -> Option<Token> {
        let map = self.borrow();
        map.get(&name.to_string()).cloned()
    }
}

