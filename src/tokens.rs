//! Tools for handling the tokens that make up strings in the L-system ([`crate::strings::ProductionString`]).
//!
//! Tokens can be of various kinds:
//!
//! * [`TokenKind::Terminal`] are the strict endpoints of the L-System. No production rule can target them.
//! * [`TokenKind::Production`] are those that can be handled by a production rule.
//!
//! Production rules ([`crate::productions::Production`]) will enforce that the target of a
//! production is a token of kind [`TokenKind::Production`].

use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::hash::{Hash, Hasher};
use std::sync::{Arc, OnceLock, RwLock, Weak};
use std::sync::atomic::{AtomicU32, Ordering};
use crate::error::Error;

type CodeStoreType = RwLock<HashMap<String, u32>>;
type NameStoreType = RwLock<HashMap<u32, String>>;

static TOKEN_REGISTER: OnceLock<CodeStoreType> = OnceLock::new();
static NAME_REGISTER: OnceLock<NameStoreType> = OnceLock::new();
static TOKEN_ID: AtomicU32 = AtomicU32::new(100);

/// Attempts to return a token code for a string.
/// 
/// If the `name` was previously seen, it will return the same code.
/// 
/// Errors are return in the following cases:
/// * The `name` is empty, or only white space. 
/// * The locks this function uses are poisoned. 
/// 
/// This is a thread safe call. 
pub fn get_code(name: &str) -> Result<u32, Error> {
    let mut register = get_code_register().write()?;
    let name = name.trim().to_string();
    
    if name.is_empty() {
        return Err(Error::general("name should not be an empty string"))
    }

    if let Some(code) = register.get(&name) {
        return Ok(*code);
    }

    let code = TOKEN_ID.fetch_add(1, Ordering::SeqCst);
    register.insert(name.clone(), code);
    drop(register);

    let mut register = get_name_register().write()?;
    register.insert(code, name);
    drop(register);

    Ok(code)
}

/// If a code was previously returned for a token name, this returns
/// that name.
pub fn get_name(code: u32) -> Option<String> {
    let register = get_name_register().read().ok()?;
    register.get(&code).cloned()
}

fn get_code_register() -> &'static CodeStoreType {
    TOKEN_REGISTER.get_or_init(|| {
        RwLock::new(HashMap::new())
    })
}

fn get_name_register() -> &'static NameStoreType {
    NAME_REGISTER.get_or_init(|| {
        RwLock::new(HashMap::new())
    })
}


/// The various kinds of tokens that can make up a [`crate::strings::ProductionString`].
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, PartialOrd)]
pub enum TokenKind {
    /// Terminals are never transformed by production rules. 
    Terminal,
    /// Production tokens may be targets for [`crate::productions::Production`] rules.
    Production
}

impl TokenKind {
    pub fn is_terminal(&self) -> bool {
        matches!(self, TokenKind::Terminal)
    }
    pub fn is_production(&self) -> bool {
        matches!(self, TokenKind::Production)
    }
}

impl Display for TokenKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            TokenKind::Terminal => f.write_str("Terminal"),
            TokenKind::Production => f.write_str("Production")
        }
    }
}

#[derive(Debug, Clone)]
pub struct Token {
    // todo remove TokenKind
    kind: TokenKind,
    code: u32,
    image: Weak<String>
}

impl PartialEq for Token {
    fn eq(&self, other: &Self) -> bool {
        self.kind == other.kind && self.code == other.code
    }
}

impl Eq for Token {}

impl Hash for Token {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.kind.hash(state);
        self.code.hash(state);
    }
}

impl Token {
    pub fn new(kind: TokenKind, code: u32, name: Weak<String>) -> Self {
        Token {
            kind, code, image: name
        }
    }

    pub fn kind(&self) -> TokenKind {
        self.kind
    }

    /// A unique identifier for the token.
    ///
    /// This identifier is set when the token is created (see [`Token::new`]).
    /// The value may not be the same when generated by different instances of [`crate::prelude::System`],
    /// and the value here should not be relied on.
    pub fn code(&self) -> u32 {
        self.code
    }

    /// The name of the string, if it has been stored.
    ///
    /// To access it, do this:
    ///
    /// ```
    /// use std::sync::Weak;
    /// use rusty_systems::tokens::{Token, TokenKind};
    /// let token = Token::new(TokenKind::Terminal, 100, Weak::default());
    ///
    /// if let Some(name) = token.name().upgrade() {
    ///     println!("The name is {name}");
    /// }
    /// ```
    pub fn name(&self) -> &Weak<String> {
        &self.image
    }

    #[inline]
    pub fn is_terminal(&self) -> bool {
        self.kind.is_terminal()
    }

    #[inline]
    pub fn is_production(&self) -> bool {
        self.kind.is_production()
    }
}

impl Display for Token {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if let Some(name) = self.name().upgrade() {
            return f.write_str(name.as_str());
        }

        write!(f, "{}[{}]", self.kind, self.code)
    }
}

pub trait TokenStore {
    fn add_token(&self, name: &str, kind: TokenKind) -> crate::Result<Token>;
    fn get_token(&self, name: &str) -> Option<Token>;
}

impl TokenStore for RefCell<HashMap<Arc<String>, Token>> {
    fn add_token(&self, name: &str, kind: TokenKind) -> crate::Result<Token> {
        let mut map = self.borrow_mut();

        let name = name.to_string();

        // If it already exists, return it.
        if let Some(value) = map.get(&name) {
            return Ok(value.clone());
        }

        let name = Arc::new(name);
        let max = map.values().map(|t| t.code).max().unwrap_or(0);
        let token = Token::new(kind, max + 1, Arc::downgrade(&name));

        map.insert(name, token.clone());
        Ok(token)
    }

    fn get_token(&self, name: &str) -> Option<Token> {
        let map = self.borrow();
        map.get(&name.to_string()).cloned()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn register_is_idempotent() {
        let hello = get_code("Hello").unwrap();
        let bye = get_code("bye").unwrap();

        assert_eq!(get_code("Hello").unwrap(), hello);
        assert_ne!(get_code("Hello").unwrap(), bye);
    }

    #[test]
    fn register_records_names() {
        let hello = "hello";
        let hcode = get_code(hello).unwrap();
     
        assert_eq!(hello, get_name(hcode).unwrap());
    }

    #[test]
    fn no_name() {
        assert!(get_name(43_432_444).is_none());
    }

    #[test]
    fn empty_string_is_error() {
        assert!(get_code("").is_err());
        assert!(get_code("  ").is_err());
        
        assert!(get_code("  d").is_ok());
    }

    #[test]
    fn names_are_trimmed() {
        let code = get_code("  d  ").unwrap();
        let code2 = get_code("d").unwrap();
        assert_eq!(code, code2);
        
        assert_eq!(get_name(code).unwrap(), "d");
        assert_eq!(get_name(code2).unwrap(), "d");
    }
}