//! Tools for handling the tokens that make up strings in the L-system ([`crate::strings::ProductionString`]).
//!
//! Tokens can be of various kinds:
//!
//! * Terminals / Constants, which are the strict endpoints of the L-System. They are not rewritten by
//!   production rules.
//! * Variable / Production tokens, are those that can be rewritten by production rules.
//!
//! Rusty-Systems does not keep track of, or enforce, these kinds.
//!
use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::hash::{Hash, Hasher};
use std::sync::{OnceLock, RwLock};
use std::sync::atomic::{AtomicU32, Ordering};
use crate::error::Error;

type CodeStoreType = RwLock<HashMap<String, u32>>;
type NameStoreType = RwLock<HashMap<u32, String>>;

static TOKEN_REGISTER: OnceLock<CodeStoreType> = OnceLock::new();
static NAME_REGISTER: OnceLock<NameStoreType> = OnceLock::new();
static TOKEN_ID: AtomicU32 = AtomicU32::new(100);

/// Attempts to return a token code for a string.
///
/// If the `name` was previously seen, it will return the same code.
///
/// Errors are return in the following cases:
/// * The `name` is empty, or only white space.
/// * The locks this function uses are poisoned.
///
/// This is a thread safe call.
pub fn get_code(name: &str) -> Result<u32, Error> {
    let mut register = get_code_register().write()?;
    let name = name.trim().to_string();

    if name.is_empty() {
        return Err(Error::general("name should not be an empty string"))
    }

    if let Some(code) = register.get(&name) {
        return Ok(*code);
    }

    let code = TOKEN_ID.fetch_add(1, Ordering::SeqCst);
    register.insert(name.clone(), code);
    drop(register);

    let mut register = get_name_register().write()?;
    register.insert(code, name);
    drop(register);

    Ok(code)
}

/// If a code was previously returned for a token name, this returns
/// that name.
pub fn get_name(code: u32) -> Option<String> {
    let register = get_name_register().read().ok()?;
    register.get(&code).cloned()
}

fn get_code_register() -> &'static CodeStoreType {
    TOKEN_REGISTER.get_or_init(|| {
        RwLock::new(HashMap::new())
    })
}

fn get_name_register() -> &'static NameStoreType {
    NAME_REGISTER.get_or_init(|| {
        RwLock::new(HashMap::new())
    })
}


#[derive(Debug, Clone, Copy)]
pub struct Token {
    code: u32
}

impl PartialEq for Token {
    fn eq(&self, other: &Self) -> bool {
        self.code == other.code
    }
}

impl Eq for Token {}

impl Hash for Token {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.code.hash(state);
    }
}

impl Token {
    #[inline]
    pub fn new(code: u32) -> Self {
        Token {
            code
        }
    }

    /// A unique identifier for the token.
    ///
    /// This identifier is set when the token is created (see [`Token::new`]).
    /// The value may not be the same when generated by different instances of [`crate::prelude::System`],
    /// and the value here should not be relied on.
    pub fn code(&self) -> u32 {
        self.code
    }
}

impl Display for Token {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if let Some(name) = get_name(self.code) {
            return f.write_str(name.as_str());
        }

        write!(f, "code:{}", self.code)
    }
}

pub trait TokenStore {
    fn add_token(&self, name: &str) -> crate::Result<Token>;
    fn get_token(&self, name: &str) -> Option<Token>;
}

impl TokenStore for RefCell<HashMap<String, Token>> {
    fn add_token(&self, name: &str) -> crate::Result<Token> {
        let mut map = self.borrow_mut();

        let name = name.to_string();

        // If it already exists, return it.
        if let Some(value) = map.get(&name) {
            return Ok(value.clone());
        }

        let token = Token::new(get_code(name.as_str())?);

        map.insert(name, token.clone());
        Ok(token)
    }

    fn get_token(&self, name: &str) -> Option<Token> {
        let map = self.borrow();
        map.get(&name.to_string()).cloned()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn register_is_idempotent() {
        let hello = get_code("Hello").unwrap();
        let bye = get_code("bye").unwrap();

        assert_eq!(get_code("Hello").unwrap(), hello);
        assert_ne!(get_code("Hello").unwrap(), bye);
    }

    #[test]
    fn register_records_names() {
        let hello = "hello";
        let hcode = get_code(hello).unwrap();

        assert_eq!(hello, get_name(hcode).unwrap());
    }

    #[test]
    fn no_name() {
        assert!(get_name(43_432_444).is_none());
    }

    #[test]
    fn empty_string_is_error() {
        assert!(get_code("").is_err());
        assert!(get_code("  ").is_err());

        assert!(get_code("  d").is_ok());
    }

    #[test]
    fn names_are_trimmed() {
        let code = get_code("  d  ").unwrap();
        let code2 = get_code("d").unwrap();
        assert_eq!(code, code2);

        assert_eq!(get_name(code).unwrap(), "d");
        assert_eq!(get_name(code2).unwrap(), "d");
    }
}